//! Type definitions for the Merkle tree primitives used in this crate.

use arrayref::mut_array_refs;
pub use rs_merkle::{Hasher, MerkleProof, MerkleTree};

pub(crate) struct VecBuf(pub(crate) Vec<u8>);

impl udigest::encoding::Buffer for VecBuf {
    fn write(&mut self, bytes: &[u8]) {
        self.0.extend_from_slice(bytes);
    }
}

/// A Merkle Tree hasher that utilizes Solana's `keccak` syscall to merge nodes.
#[cfg(any(feature = "solana", test))]
#[derive(Copy, Clone)]
pub struct SolanaSyscallHasher;

#[cfg(any(feature = "solana", test))]
impl rs_merkle::Hasher for SolanaSyscallHasher {
    type Hash = [u8; 32];

    fn hash(data: &[u8]) -> Self::Hash {
        solana_program::keccak::hashv(&[data]).to_bytes()
    }

    fn concat_and_hash(left: &Self::Hash, right: Option<&Self::Hash>) -> Self::Hash {
        concat_and_hash(left, right, Self::hash)
    }
}

#[cfg(any(feature = "solana", test))]
impl HashvSupport for SolanaSyscallHasher {
    fn hashv(data: &[&[u8]]) -> [u8; 32] {
        solana_program::keccak::hashv(data).to_bytes()
    }
}

/// Trait providing support for hashing multiple byte slices.
///
/// The `HashvSupport` trait defines a method for hashing multiple byte slices
/// in a single operation, facilitating more efficient and flexible hashing
/// processes required by Merkle trees.
pub trait HashvSupport {
    /// Hashes multiple byte slices and returns a single 32-byte hash.
    ///
    /// # Arguments
    ///
    /// * `vals` - A slice of byte slices to be hashed together.
    ///
    /// # Returns
    ///
    /// A 32-byte array representing the combined hash of the input slices.
    fn hashv(vals: &[&[u8]]) -> [u8; 32];
}

/// A Merkle Tree hasher that uses the native `sha3` crate's `Keccak256` hashing
/// algorithm.
///
/// The `NativeHasher` is suitable for environments outside of Solana, providing
/// a reliable and efficient hashing mechanism for Merkle tree operations.
#[derive(Copy, Clone)]
pub struct NativeHasher;

impl HashvSupport for NativeHasher {
    fn hashv(vals: &[&[u8]]) -> [u8; 32] {
        use sha3::digest::Digest;
        let mut hasher = sha3::Keccak256::default();
        for val in vals {
            hasher.update(val);
        }
        let res = hasher.finalize();
        res.into()
    }
}

impl rs_merkle::Hasher for NativeHasher {
    type Hash = [u8; 32];

    fn hash(data: &[u8]) -> Self::Hash {
        use sha3::digest::Digest;
        let mut hasher = sha3::Keccak256::default();
        hasher.update(data);
        hasher.finalize().into()
    }

    fn concat_and_hash(left: &Self::Hash, right: Option<&Self::Hash>) -> Self::Hash {
        concat_and_hash(left, right, Self::hash)
    }
}

/// This implementation deviates from the default for several reasons:
/// 1. It prefixes intermediate nodes before hashing to prevent second preimage
///    attacks. This distinguishes leaf nodes from intermediates, blocking
///    attempts to craft alternative trees with the same root hash using
///    malicious hashes.
/// 2. If the left node doesn't have a sibling it is concatenated to itself and
///    then hashed instead of just being propagated to the next level.
/// 3. It uses arrays instead of vectors to avoid heap allocations.
#[inline]
fn concat_and_hash(
    left: &[u8; 32],
    right: Option<&[u8; 32]>,
    hash_fn: fn(&[u8]) -> [u8; 32],
) -> [u8; 32] {
    let mut concatenated: [u8; 65] = [0; 65];
    let (prefix, left_node, right_node) = mut_array_refs![&mut concatenated, 1, 32, 32];
    prefix[0] = 1;
    left_node.copy_from_slice(left);
    right_node.copy_from_slice(right.unwrap_or(left));
    hash_fn(&concatenated)
}

#[cfg(test)]
mod tests {
    use core::array;

    use rand::rngs::OsRng;
    use rand::Rng;

    use super::*;

    fn random_bytes<const N: usize>() -> [u8; N] {
        let mut bytes = [0_u8; N];
        OsRng.fill(&mut bytes[..]);
        bytes
    }

    /// Tests that the hashing functions of both `SolanaSyscallHasher` and
    /// `DefaultHasher` produce identical results for the same input data.
    #[test]
    fn hash_equivalence_across_impls() {
        let data = random_bytes::<256>();
        assert_eq!(
            SolanaSyscallHasher::hash(&data),
            NativeHasher::hash(&data),
            "Hashes from SolanaSyscallHasher and DefaultHasher should be equal"
        );
    }

    /// Tests that Merkle proofs generated by both `SolanaSyscallHasher` and
    /// `DefaultHasher` are consistent and can be verified between
    /// implementations
    #[allow(clippy::indexing_slicing)]
    #[test]
    fn proof_equivalence_between_impls() {
        const NUM_LEAVES: usize = 100;
        // Generate a fixed number of random leaves for the Merkle trees
        let leaves: [[u8; 32]; NUM_LEAVES] = array::from_fn(|_| random_bytes());

        // Create Merkle trees using both hasher implementations
        let keccak_tree = MerkleTree::<NativeHasher>::from_leaves(&leaves);
        let solana_tree = MerkleTree::<SolanaSyscallHasher>::from_leaves(&leaves);

        // Both trees should have the same root hash
        let keccak_root = keccak_tree.root().expect("Keccak tree should have a root");
        let solana_root = solana_tree.root().expect("Solana tree should have a root");
        assert_eq!(
            keccak_root, solana_root,
            "Root hashes of both Merkle trees should match"
        );

        // Generate Merkle proofs for each leaf in both trees
        let keccak_proofs: [MerkleProof<_>; NUM_LEAVES] =
            array::from_fn(|idx| keccak_tree.proof(&[idx]));
        let solana_proofs: [MerkleProof<_>; NUM_LEAVES] =
            array::from_fn(|idx| solana_tree.proof(&[idx]));

        // Each corresponding pair of proofs should be identical
        for (idx, (solana_proof, keccak_proof)) in
            solana_proofs.iter().zip(keccak_proofs.iter()).enumerate()
        {
            let sol_proof_bytes = solana_proof.to_bytes();
            let keccak_proof_bytes = keccak_proof.to_bytes();
            assert_eq!(
                sol_proof_bytes, keccak_proof_bytes,
                "Proof bytes for leaf index {idx} should match between implementations",
            );
        }

        // Proofs should be valid
        for (idx, leaf) in leaves.iter().enumerate() {
            assert!(
                keccak_proofs[idx].verify(keccak_root, &[idx], &[*leaf], NUM_LEAVES),
                "Keccak Merkle proof should be valid for leaf index {idx}",
            );
            assert!(
                solana_proofs[idx].verify(solana_root, &[idx], &[*leaf], NUM_LEAVES),
                "SolanaSyscall Merkle proof should be valid for leaf index {idx}",
            );
        }
    }
}
